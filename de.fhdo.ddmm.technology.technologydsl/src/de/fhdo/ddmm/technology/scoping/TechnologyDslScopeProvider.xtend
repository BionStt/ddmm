/*
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.technology.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import de.fhdo.ddmm.technology.Protocol
import de.fhdo.ddmm.technology.TechnologyPackage
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.MapBasedScope
import org.eclipse.xtext.resource.EObjectDescription

/**
 * This class implements a custom scope provider for the Technology DSL.
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de>Florian Rademacher</a>
 */
class TechnologyDslScopeProvider extends AbstractTechnologyDslScopeProvider {
    /**
     * Build scope for a given context and reference
     */
    override getScope(EObject context, EReference reference) {
        if (context instanceof Protocol &&
            reference == TechnologyPackage::Literals.PROTOCOL__DEFAULT_FORMAT)
            return (context as Protocol).getScope(reference)
        else
            return super.getScope(context, reference)
    }

    /**
     * Build scope for protocol default formats
     */
    private def getScope(Protocol protocol, EReference reference) {
        if (protocol === null)
            return IScope.NULLSCOPE

        // Only a data format defined for the protocol can also be its default protocol
        val scopeElements = protocol.dataFormats.map[
            EObjectDescription.create(it.formatName, it)
        ]

        // Note, that we use a map-based scope here, because the DataFormat metamodel element has
        // no "name" attribute, but a "formatName" attribute, to exclude it from being automatically
        // checked by the unique names validator. That is, because the name of a protocol must only
        // be unique within its protocol, but not the overall model (i.e., over all protocols).
        return MapBasedScope.createScope(IScope.NULLSCOPE, scopeElements)
    }
}
