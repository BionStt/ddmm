/*
 * generated by Xtext 2.12.0
 */
package de.fhdo.ddmm.technology.validation

import org.eclipse.xtext.validation.Check
import de.fhdo.ddmm.technology.TechnologyPackage
import de.fhdo.ddmm.technology.Technology
import de.fhdo.ddmm.technology.CommunicationType
import de.fhdo.ddmm.technology.TechnologySpecificPrimitiveType
import de.fhdo.ddmm.data.PrimitiveType

/**
 * This class contains custom validation rules.
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de>Florian Rademacher</a>
 */
class TechnologyDslValidator extends AbstractTechnologyDslValidator {
    /**
     * Check that there are not duplicates in the basic built-ins of a technology-specific primitive
     * type
     */
    @Check
    def checkBascBuiltinsUnique(TechnologySpecificPrimitiveType primitiveType) {
        // Note that we use the metamodel interfaces to check for duplicates. That is, because at
        // runtime, only their implementations are available (e.g., instead of PrimitiveBoolean
        // PrimitiveBooleanImpl).
        val basicBuiltins = primitiveType.basicBuiltinPrimitiveTypes.map[class.interfaces.get(0)]
        var PrimitiveType duplicate = null
        var Integer duplicateIndex = null

        // The following construct is just a "classic" search for element duplicates in two lists
        var i = 0
        while (i < basicBuiltins.size - 1 && duplicate === null) {
            val builtin = basicBuiltins.get(i)

            var n = i + 1
            while (n < basicBuiltins.size && duplicate === null) {
                val builtinDuplicateToCheck = basicBuiltins.get(n)

                if (builtinDuplicateToCheck == builtin) {
                    duplicate = primitiveType.basicBuiltinPrimitiveTypes.get(n)
                    duplicateIndex = n
                }

                n++
            }

            i++
        }

        if (duplicate !== null)
            error('''«duplicate.typeName» is already a basic type for «primitiveType.name»''',
                primitiveType, TechnologyPackage::Literals
                    .TECHNOLOGY_SPECIFIC_PRIMITIVE_TYPE__BASIC_BUILTIN_PRIMITIVE_TYPES,
                duplicateIndex
            )
    }

    /**
     * Check that there is only one technology-specific primitive type that is marked as the default
     * for a built-in primitive type. Otherwise, the code generator could not unambiguously decide
     * which technology-specific primitive type to use, when no explicit mapping of a built-in
     * primitive types was specified.
     */
    @Check
    def checkPrimitiveDefaultsUnique(TechnologySpecificPrimitiveType primitiveType) {
        if (!primitiveType.^default) {
            return
        }

        val otherDefaultPrimitiveTypes = primitiveType.technology.primitiveTypes
            .filter[^default && it !== primitiveType]
        val primitiveTypeBuiltins = primitiveType.basicBuiltinPrimitiveTypes
            .map[class.interfaces.get(0)]

        var TechnologySpecificPrimitiveType duplicateContainer = null
        var String duplicateName = null
        var Integer duplicateIndex = null
        var i = 0
        while (i < otherDefaultPrimitiveTypes.size && duplicateContainer === null) {
            val otherDefaultPrimitiveType = otherDefaultPrimitiveTypes.get(i)
            val otherBuiltins = otherDefaultPrimitiveType.basicBuiltinPrimitiveTypes
            var n = 0
            while (n < otherBuiltins.size && duplicateContainer === null) {
                val otherBuiltin = otherBuiltins.get(n).class.interfaces.get(0)
                if (primitiveTypeBuiltins.contains(otherBuiltin)) {
                    duplicateContainer = otherDefaultPrimitiveType
                    duplicateName = otherBuiltins.get(n).typeName
                    duplicateIndex = n
                }
                n++
            }
            i++
        }

        if (duplicateContainer !== null)
            error('''Duplicate default type: «primitiveType.name» is also specified as default ''' +
                '''type for built-in primitive «duplicateName»''',
                duplicateContainer, TechnologyPackage::Literals
                    .TECHNOLOGY_SPECIFIC_PRIMITIVE_TYPE__BASIC_BUILTIN_PRIMITIVE_TYPES,
                duplicateIndex
            )
    }

    /**
     * Check that technology defines at least one default technology-specific primitive type for
     * each built-in primitive type. This ensures, that even if there is no mapping of a built-in
     * primitive type to a technology-specific one, we can deduce a technology-specific type for it
     * when code gets generated.
     */
    @Check
    def checkPrimitiveDefaults(Technology technology) {
        /*
         * Get built-in primitive types of technology-specific primitive types, which are marked as
         * defaults for the basic built-in primitive types. Here, we map them to the metamodel
         * interfaces of the built-in primitive types. That is, because at runtime, instead of,
         * e.g., PrimitiveBoolean (which is a concept from the metamodel and an Ecore interface),
         * its implementing class PrimitiveBooleanImpl will be used.
         */
        val specificDefaultPrimitivesBasics = technology.primitiveTypes
            .filter[^default]
            .map[basicBuiltinPrimitiveTypes]
            .flatten
            .map[class.interfaces.get(0)]
            .toList

        if (specificDefaultPrimitivesBasics.empty) {
            error("Technology must define at least one default primitive type for each built-in " +
                  "primitive type", technology, TechnologyPackage::Literals.TECHNOLOGY__NAME)
            return
        }

        /*
         * Get list of all built-in primitive types, i.e., their metamodel interfaces. To be able
         * to retrieve the list from the metamodel, we need an instance of a PrimitiveType to be
         * able to call getBuiltinPrimitiveTypes() as Xcore does not allow static methods.
         */
        val primitiveTypeInstance = technology
            .primitiveTypes.get(0)
            .basicBuiltinPrimitiveTypes.get(0)
        val builtinPrimitives = primitiveTypeInstance.builtinPrimitiveTypes

        /*
         * Throw error if list of default, technology-specific primitive types' basic built-in
         * primitive types does not exhibit all built-in primitive types. That is, there are not
         * defaults defined for each built-in primitive type.
         */
        if (!specificDefaultPrimitivesBasics.containsAll(builtinPrimitives))
            error("Technology must define at least one default primitive type for each built-in " +
                  "primitive type", technology, TechnologyPackage::Literals.TECHNOLOGY__NAME)
    }

    /**
     * Check that there is exactly one default protocol for each communication type
     */
    @Check
    def checkProtocolDefaults(Technology technology) {
        checkProtocolsDefaults(technology, CommunicationType.SYNCHRONOUS)
        checkProtocolsDefaults(technology, CommunicationType.ASYNCHRONOUS)
    }

    /**
     * Convenience method to check protocol defaults
     */
    def checkProtocolsDefaults(Technology technology, CommunicationType forCommunicationType) {
        val communicationTypeString = switch (forCommunicationType) {
            case SYNCHRONOUS: "synchronous"
            case ASYNCHRONOUS: "asynchronous"
            default: ""
        }

        val definedDefaultProtocols = technology.protocols
            .filter[^default && communicationType == forCommunicationType]

        if (definedDefaultProtocols.empty)
            error('''Technology must define at least one default «communicationTypeString» ''' +
                '''protocol''', technology, TechnologyPackage::Literals.TECHNOLOGY__NAME)
        else if (definedDefaultProtocols.size >= 2)
            error('''Technology may not define more than one default «communicationTypeString» ''' +
                '''protocol''', definedDefaultProtocols.get(1),
                TechnologyPackage::Literals.PROTOCOL__NAME)
    }
}
