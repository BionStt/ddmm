package de.fhdo.ddmm.technology

import de.fhdo.ddmm.data.DataStructure
import de.fhdo.ddmm.data.ListType
import de.fhdo.ddmm.data.PrimitiveType
import de.fhdo.ddmm.data.PrimitiveValue
import de.fhdo.ddmm.data.Type

/**
 * Root model concept, which represents all concept related to a certain technology that maps
 * microservices to technology
 *
 * @author <a href="mailto:florian.rademacher@fh-dortmund.de>Florian Rademacher</a>
 */
class Technology {
    /**
     * Implicit Constraints:
     *     (C1) A technology must define at least one default technology-specific primitive type for
     *          each built-in primitive type. This ensures, that even if there is no mapping of a
     *          built-in primitive type to a technology-specific one, we can deduce a
     *          technology-specific type for it when code gets generated.
     *          Ensured by: DSL validator.
     *     (C2) A technology must define at least one default communication protocol for either type
     *          of communication.
     *          Ensured by: DSL validator.
     */

    String name

    contains TechnologyImport[] imports opposite technology
    contains TechnologySpecificPrimitiveType[] primitiveTypes opposite technology
    contains TechnologySpecificListType[] listTypes opposite technology
    contains TechnologySpecificDataStructure[] dataStructures opposite technology
    contains CompatibilityMatrixEntry[] compatibilityEntries opposite technology
    contains Protocol[] protocols opposite technology
    contains DeploymentTechnology[] deploymentTechnologies opposite technology
    contains InfrastructureTechnology[] infrastructureTechnologies opposite technology
}

/**
 * Concept for importing another technology
 */
class TechnologyImport {
    /**
     * Implicit Constraints:
     *     (C1) The import URI must point to a valid file.
     *          Ensured by: DSL validator.
     *     (C2) Model may not import itself. However, cyclic imports are allowed, because otherwise
     *          it would not be possible to declare that types of two different technologies are
     *          bidirectionally compatible (see implicit constraints of CompatibilityMatrixEntry for
     *          details on this).
     *          Ensured by: DSL validator.
     *     (C3) Import names, i.e., "aliases", must be unique.
     *          Ensured by: DSL validator.
     */

    String name
    String importURI

    container Technology technology opposite imports
}

/**
 * Possible types of communication
 */
enum CommunicationType {
    SYNCHRONOUS
    ASYNCHRONOUS
}

/**
 * Represents a data exchange protocol for microservice communications, e.g., AMQP
 */
class Protocol {
    /**
     * Implicit Constraints:
     *     (C1) The default format must be one of the data formats assigned to the protocol.
     *          Ensured by: DSL scope provider.
     *     (C2) Name must be unique.
     *          Ensured by: DSL validator.
     */

    String name
    CommunicationType communicationType = 'SYNCHRONOUS'
    boolean ^default = "false"

    refers DataFormat defaultFormat
    contains DataFormat[1..*] dataFormats opposite protocol

    container Technology technology opposite protocols

    /**
     * Get parts of the protocol for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = newArrayList
        nameParts.add("protocols")
        nameParts.add(name)
        nameParts.asEList
    }
}

/**
 * Protocol-specific data format, e.g., XML for AMQP
 */
class DataFormat {
    /**
     * Implicit Constraints:
     *     (C1) Name must be unique within a protocol.
     *          Ensured by: DSL validator.
     */

    String formatName

    container Protocol protocol opposite dataFormats
}

/**
 * A primitive type that is specific to a certain technology, e.g., uint64 for Go
 */
class TechnologySpecificPrimitiveType extends PrimitiveType {
    /**
     * Implicit Constraints:
     *     (C1) There might be no duplicates in the basic built-ins of a technology-specific
     *          primitive type.
     *          Ensured by: DSL validator.
     *     (C2) There might be only one technology-specific primitive type that is marked as the
     *          default for a built-in primitive type. Otherwise, the code generator could not
     *          unambiguously decide which technology-specific primitive type to use, when no
     *          explicit mapping of a built-in primitive types was specified.
     *          Ensured by: DSL validator.
     *     (C3) Name must be unique.
     *          Ensured by: DSL validator.
     */

    String name
    boolean ^default = "false"

    container Technology technology opposite primitiveTypes

    contains PrimitiveType[] basicBuiltinPrimitiveTypes

    /**
     * Get parts of the type for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = newArrayList
        nameParts.add("types")
        nameParts.add(name)
        nameParts.asEList
    }
}

/**
 * A list type that is specific to a certain technology, e.g., Queue for Java
 */
class TechnologySpecificListType extends ListType {
    /**
     * Implicit Constraints:
     *     (C1) Name must be unique.
     *          Ensured by: DSL validator.
     */

    container Technology technology opposite listTypes

    /**
     * Get parts of the type for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = newArrayList
        nameParts.add("types")
        nameParts.add(name)
        nameParts.asEList
    }
}

/**
 * A data structure type that is specific to a certain technology
 */
class TechnologySpecificDataStructure extends DataStructure {
    /**
     * Implicit Constraints:
     *     (C1) Name must be unique.
     *          Ensured by: DSL validator.
     */

    container Technology technology opposite dataStructures

    /**
     * Get parts of the type for creating a qualified name
     */
    op String[] getQualifiedNameParts() {
        if (name === null || name.empty)
            return newArrayList.asEList

        val nameParts = newArrayList
        nameParts.add("types")
        nameParts.add(name)
        nameParts.asEList
    }
}

/**
 * Represents the direction of compatibility in a compatibility matrix entry.
 *
 * Semantics:
 *     - MAPPING_TO_COMPATIBLE_TYPES: The mapping type of the entry may be converted into instances
 *                                    the compatible types.
 *     - COMPATIBLE_TYPES_TO_MAPPING: The compatible types of the entry may be converted into an
 *                                    instance of the mapping type.
 *     - BIDIRECTONAL: Both conversion directions are possible.
 */
enum CompatibilityDirection {
    MAPPING_TO_COMPATIBLE_TYPES,
    COMPATIBLE_TYPES_TO_MAPPING,
    BIDIRECTIONAL
}

/**
 * Entry for declaring technology-specific compatibility between a mapping type and a set of other
 * technology-specific types. The conversion direction is determined leveraging an
 * CompatibilityDirection-typed field.
 */
class CompatibilityMatrixEntry {
    /**
     * Implicit Constraints:
     *     (C1) No duplicate entries.
     *          Ensured by: DSL validator.
     *     (C2) No ambiguous entries in case of bidirectional compatibility, e.g., when comprising a
     *          Boolean <-> Character mapping the matrix may not have any of the entries Boolean ->
     *          Character or Character -> Boolean.
     *          Ensured by: DSL validator.
     *     (C3) For imported types, only the forms "imported compatible types -> local mapping type"
     *          or "local compatible types <- imported mapping type" is allowed. That is, the
     *          compatibility matrix must declare which imported types may be converted _into_ its
     *          types. A bidirectional compatibility direction is prevented, because then all
     *          imported technology models must be traversed to decide whether a compatibility
     *          entry exists. Furthermore, for an entry with imported types it must always be
     *          declared that imported types are convertible into local types. This follows the
     *          direction of an initialized parameter of a microservices that has a technology
     *          assigned.
     *          Ensured by: DSL validator.
     */

    CompatibilityDirection direction
    contains PossiblyImportedTechnologySpecificType mappingType opposite mappingEntry
    contains PossiblyImportedTechnologySpecificType[1..*] compatibleTypes opposite compatibleEntry

    container Technology technology opposite compatibilityEntries
}

/**
 * A technology-specific type possibly imported from another technology model
 */
class PossiblyImportedTechnologySpecificType {
    refers TechnologyImport[0..1] ^import
    refers Type ^type

    container CompatibilityMatrixEntry mappingEntry opposite mappingType
    container CompatibilityMatrixEntry compatibleEntry opposite compatibleTypes
}

/**
 * Abstract superclass of technologies specific to service operation
 */
abstract class OperationTechnology {
    String name

    contains OperationEnvironment[1..*] operationEnvironments opposite operationTechnology
    contains ServiceProperty[] serviceProperties opposite operationTechnology
}

/**
 * Operation environment of an operation technology, e.g., an image of a deployment container
 */
class OperationEnvironment {
    /**
     * Implicit Constraints:
     *     (C1) Name must be unique.
     *          Ensured by: DSL validator.
     *     (C2) If there is more than one operation environment within an operation technology, than
     *          there must be at least one default environment.
     *          Ensured by: DSL validator.
     */

    String name
    boolean ^default = "false"

    container OperationTechnology operationTechnology opposite operationEnvironments
}

/**
 * A property of an operation technology that may be set per associated service
 */
class ServiceProperty {
    /**
     * Implicit Constraints:
     *     (C1) A mandatory property may not have a default value.
     *          Ensured by: DSL grammar.
     *     (C2) The assigned default value must be compatible with the poperty's type.
     *          Ensured by: DSL validator.
     *     (C3) Name must be unique.
     *          Ensured by: DSL validator.
     */

    String name
    boolean mandatory = "false"

    container OperationTechnology operationTechnology opposite serviceProperties

    contains PrimitiveType ^type
    contains PrimitiveValue defaultValue
}

/**
 * Operation technology for service deployment
 */
class DeploymentTechnology extends OperationTechnology {
    /**
     * Implicit Constraints:
     *     (C1) Name must be unique.
     *          Ensured by: DSL validator.
     */

    container Technology technology opposite deploymentTechnologies
}

/**
 * Infrastructure technology for service operation
 */
class InfrastructureTechnology extends OperationTechnology {
    /**
     * Implicit Constraints:
     *     (C1) Name must be unique.
     *          Ensured by: DSL validator.
     */

    container Technology technology opposite infrastructureTechnologies
}